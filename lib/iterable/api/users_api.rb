=begin
#Iterable API

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 1.8

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.32
=end

module Iterable
  class UsersApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Bulk update user subscriptions
    # <b>WARNING</b>: This will overwrite (instead of merging) existing data if the provided fields are not null.
    # @param body Bulk subscriptions to update
    # @param [Hash] opts the optional parameters
    # @return [BulkUpdateSubscriptionsResponse]
    def bulk_update_subscriptions(body, opts = {})
      data, _status_code, _headers = bulk_update_subscriptions_with_http_info(body, opts)
      data
    end

    # Bulk update user subscriptions
    # &lt;b&gt;WARNING&lt;/b&gt;: This will overwrite (instead of merging) existing data if the provided fields are not null.
    # @param body Bulk subscriptions to update
    # @param [Hash] opts the optional parameters
    # @return [Array<(BulkUpdateSubscriptionsResponse, Integer, Hash)>] BulkUpdateSubscriptionsResponse data, response status code and response headers
    def bulk_update_subscriptions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.bulk_update_subscriptions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.bulk_update_subscriptions"
      end
      # resource path
      local_var_path = '/api/users/bulkUpdateSubscriptions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'BulkUpdateSubscriptionsResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#bulk_update_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Bulk update user data
    # Bulk update user data. This will add the data if it doesn't exist yet. Data will be merged; missing fields are not deleted. Changing emailListIds, unsubscribedChannelIds, messageTypeIds through this endpoint will <b>NOT</b> generate unsubscribe events. However, the bulkUpdateSubscription will generate unsubscribe events. Also, note that there is a soft limit on the number of unique fields a user can have (default is 1,000). Types of data fields must match the types sent in previous requests, across all data fields in the project.<br>Note that bulk updates are processed separately from single-user calls (update, updateEmail, updateSubscriptions, etc). If the same user is modified using both bulk update and single-user calls made near the same time, the results may be inconsistent. It's important to use either only single-user calls or only bulk update calls around the same time for any given user.<br><b>Rate limit</b>: 5 requests/second, per project.
    # @param body Users to update
    # @param [Hash] opts the optional parameters
    # @return [ListResponse]
    def bulk_update_user(body, opts = {})
      data, _status_code, _headers = bulk_update_user_with_http_info(body, opts)
      data
    end

    # Bulk update user data
    # Bulk update user data. This will add the data if it doesn&#x27;t exist yet. Data will be merged; missing fields are not deleted. Changing emailListIds, unsubscribedChannelIds, messageTypeIds through this endpoint will &lt;b&gt;NOT&lt;/b&gt; generate unsubscribe events. However, the bulkUpdateSubscription will generate unsubscribe events. Also, note that there is a soft limit on the number of unique fields a user can have (default is 1,000). Types of data fields must match the types sent in previous requests, across all data fields in the project.&lt;br&gt;Note that bulk updates are processed separately from single-user calls (update, updateEmail, updateSubscriptions, etc). If the same user is modified using both bulk update and single-user calls made near the same time, the results may be inconsistent. It&#x27;s important to use either only single-user calls or only bulk update calls around the same time for any given user.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 5 requests/second, per project.
    # @param body Users to update
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListResponse, Integer, Hash)>] ListResponse data, response status code and response headers
    def bulk_update_user_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.bulk_update_user ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.bulk_update_user"
      end
      # resource path
      local_var_path = '/api/users/bulkUpdate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'ListResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#bulk_update_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete a user by email
    # Asynchronous. Delete a specific user by email address. <b>Rate limit</b>: 3 requests/second, per project.
    # @param email email
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def delete(email, opts = {})
      data, _status_code, _headers = delete_with_http_info(email, opts)
      data
    end

    # Delete a user by email
    # Asynchronous. Delete a specific user by email address. &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param email email
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def delete_with_http_info(email, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete ...'
      end
      # verify the required parameter 'email' is set
      if @api_client.config.client_side_validation && email.nil?
        fail ArgumentError, "Missing the required parameter 'email' when calling UsersApi.delete"
      end
      # resource path
      local_var_path = '/api/users/{email}'.sub('{' + 'email' + '}', email.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Delete user by userId
    # Asynchronous. Delete user by a userId. This will delete multiple users if they happen to share the same userId. <b>Rate limit</b>: 3 requests/second, per project.
    # @param user_id 
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def delete_0(user_id, opts = {})
      data, _status_code, _headers = delete_0_with_http_info(user_id, opts)
      data
    end

    # Delete user by userId
    # Asynchronous. Delete user by a userId. This will delete multiple users if they happen to share the same userId. &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param user_id 
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def delete_0_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete_0 ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.delete_0"
      end
      # resource path
      local_var_path = '/api/users/byUserId/{userId}'.sub('{' + 'userId' + '}', user_id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Disable pushes to a mobile device
    # Manually disable push notifications to a device until it comes online again.
    # @param [Hash] opts the optional parameters
    # @option opts [DisableDeviceRequest] :body Request to disable device
    # @return [IterableApiResponse]
    def disable_device(opts = {})
      data, _status_code, _headers = disable_device_with_http_info(opts)
      data
    end

    # Disable pushes to a mobile device
    # Manually disable push notifications to a device until it comes online again.
    # @param [Hash] opts the optional parameters
    # @option opts [DisableDeviceRequest] :body Request to disable device
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def disable_device_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.disable_device ...'
      end
      # resource path
      local_var_path = '/api/users/disableDevice'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(opts[:'body']) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#disable_device\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get hashed forgotten users in compliance with GDPR
    # Get all hashed user emails that are currently in the blacklist. In order to calculate the hash, every email is lowercased, trimmed and hashed using SHA-256.<br><b>Rate limit</b>: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @return [GetForgottenUserEmailsResponse]
    def export_project_forgotten_users(opts = {})
      data, _status_code, _headers = export_project_forgotten_users_with_http_info(opts)
      data
    end

    # Get hashed forgotten users in compliance with GDPR
    # Get all hashed user emails that are currently in the blacklist. In order to calculate the hash, every email is lowercased, trimmed and hashed using SHA-256.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetForgottenUserEmailsResponse, Integer, Hash)>] GetForgottenUserEmailsResponse data, response status code and response headers
    def export_project_forgotten_users_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.export_project_forgotten_users ...'
      end
      # resource path
      local_var_path = '/api/users/forgotten'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'GetForgottenUserEmailsResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#export_project_forgotten_users\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Forget a user in compliance with GDPR
    # Delete the specified user's data from the Iterable project and prevent future data collection about them.<br><b>Rate limit</b>: 3 requests/second, per project.
    # @param body user&#x27;s email to be added to blacklist.
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def forget(body, opts = {})
      data, _status_code, _headers = forget_with_http_info(body, opts)
      data
    end

    # Forget a user in compliance with GDPR
    # Delete the specified user&#x27;s data from the Iterable project and prevent future data collection about them.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param body user&#x27;s email to be added to blacklist.
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def forget_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.forget ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.forget"
      end
      # resource path
      local_var_path = '/api/users/forget'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#forget\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get messages sent to a user
    # Get messages sent to a user by email address or user ID. Returns 10 by default, up to 1,000. <b>Rate limit</b>: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :email user&#x27;s email, either email or userId must be specified
    # @option opts [String] :user_id user&#x27;s userId, either email or userId must be specified
    # @option opts [Integer] :limit max number of messages to return (default: 10, max limit: 1000) (default to 10)
    # @option opts [Array<Object>] :campaign_ids only include messages from these campaigns
    # @option opts [DateTime] :start_date_time start date time (yyyy-MM-dd HH:mm:ss ZZ)
    # @option opts [DateTime] :end_date_time end date time (yyyy-MM-dd HH:mm:ss ZZ)
    # @option opts [BOOLEAN] :exclude_blast_campaigns exclude results coming from blast campaigns (ignored if campaignId is set) (default to false)
    # @option opts [String] :message_medium only include messages of this type
    # @return [GetSentMessagesResponse]
    def get_sent_messages(opts = {})
      data, _status_code, _headers = get_sent_messages_with_http_info(opts)
      data
    end

    # Get messages sent to a user
    # Get messages sent to a user by email address or user ID. Returns 10 by default, up to 1,000. &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :email user&#x27;s email, either email or userId must be specified
    # @option opts [String] :user_id user&#x27;s userId, either email or userId must be specified
    # @option opts [Integer] :limit max number of messages to return (default: 10, max limit: 1000)
    # @option opts [Array<Object>] :campaign_ids only include messages from these campaigns
    # @option opts [DateTime] :start_date_time start date time (yyyy-MM-dd HH:mm:ss ZZ)
    # @option opts [DateTime] :end_date_time end date time (yyyy-MM-dd HH:mm:ss ZZ)
    # @option opts [BOOLEAN] :exclude_blast_campaigns exclude results coming from blast campaigns (ignored if campaignId is set)
    # @option opts [String] :message_medium only include messages of this type
    # @return [Array<(GetSentMessagesResponse, Integer, Hash)>] GetSentMessagesResponse data, response status code and response headers
    def get_sent_messages_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_sent_messages ...'
      end
      if @api_client.config.client_side_validation && opts[:'message_medium'] && !['Email', 'Push', 'InApp', 'SMS'].include?(opts[:'message_medium'])
        fail ArgumentError, 'invalid value for "message_medium", must be one of Email, Push, InApp, SMS'
      end
      # resource path
      local_var_path = '/api/users/getSentMessages'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'email'] = opts[:'email'] if !opts[:'email'].nil?
      query_params[:'userId'] = opts[:'user_id'] if !opts[:'user_id'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'campaignIds'] = @api_client.build_collection_param(opts[:'campaign_ids'], :multi) if !opts[:'campaign_ids'].nil?
      query_params[:'startDateTime'] = opts[:'start_date_time'] if !opts[:'start_date_time'].nil?
      query_params[:'endDateTime'] = opts[:'end_date_time'] if !opts[:'end_date_time'].nil?
      query_params[:'excludeBlastCampaigns'] = opts[:'exclude_blast_campaigns'] if !opts[:'exclude_blast_campaigns'].nil?
      query_params[:'messageMedium'] = opts[:'message_medium'] if !opts[:'message_medium'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'GetSentMessagesResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_sent_messages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a user by email
    # <b>Rate limit</b>: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :email 
    # @return [UserResponse]
    def get_user(opts = {})
      data, _status_code, _headers = get_user_with_http_info(opts)
      data
    end

    # Get a user by email
    # &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :email 
    # @return [Array<(UserResponse, Integer, Hash)>] UserResponse data, response status code and response headers
    def get_user_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user ...'
      end
      # resource path
      local_var_path = '/api/users/getByEmail'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'email'] = opts[:'email'] if !opts[:'email'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'UserResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a user by email
    # Get a user by their email address.<br><b>Note</b>: If the email address contains non-alphanumeric characters, please use the <a href=\"https://api.iterable.com/api/docs#users_getUser_0\"><tt>GET /api/users/getByEmail</tt></a> endpoint instead.<br><b>Rate limit</b>: 3 requests/second, per project.
    # @param email email
    # @param [Hash] opts the optional parameters
    # @return [UserResponse]
    def get_user_0(email, opts = {})
      data, _status_code, _headers = get_user_0_with_http_info(email, opts)
      data
    end

    # Get a user by email
    # Get a user by their email address.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: If the email address contains non-alphanumeric characters, please use the &lt;a href&#x3D;\&quot;https://api.iterable.com/api/docs#users_getUser_0\&quot;&gt;&lt;tt&gt;GET /api/users/getByEmail&lt;/tt&gt;&lt;/a&gt; endpoint instead.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param email email
    # @param [Hash] opts the optional parameters
    # @return [Array<(UserResponse, Integer, Hash)>] UserResponse data, response status code and response headers
    def get_user_0_with_http_info(email, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user_0 ...'
      end
      # verify the required parameter 'email' is set
      if @api_client.config.client_side_validation && email.nil?
        fail ArgumentError, "Missing the required parameter 'email' when calling UsersApi.get_user_0"
      end
      # resource path
      local_var_path = '/api/users/{email}'.sub('{' + 'email' + '}', email.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'UserResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a user by userId
    # <b>Rate limit</b>: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :user_id 
    # @return [UserResponse]
    def get_user_by_id(opts = {})
      data, _status_code, _headers = get_user_by_id_with_http_info(opts)
      data
    end

    # Get a user by userId
    # &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :user_id 
    # @return [Array<(UserResponse, Integer, Hash)>] UserResponse data, response status code and response headers
    def get_user_by_id_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user_by_id ...'
      end
      # resource path
      local_var_path = '/api/users/byUserId'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'userId'] = opts[:'user_id'] if !opts[:'user_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'UserResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get a user by userId
    # Get a user by your custom userId. <b>Rate limit</b>: 3 requests/second, per project.
    # @param user_id userId
    # @param [Hash] opts the optional parameters
    # @return [UserResponse]
    def get_user_by_id_0(user_id, opts = {})
      data, _status_code, _headers = get_user_by_id_0_with_http_info(user_id, opts)
      data
    end

    # Get a user by userId
    # Get a user by your custom userId. &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param user_id userId
    # @param [Hash] opts the optional parameters
    # @return [Array<(UserResponse, Integer, Hash)>] UserResponse data, response status code and response headers
    def get_user_by_id_0_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user_by_id_0 ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.get_user_by_id_0"
      end
      # resource path
      local_var_path = '/api/users/byUserId/{userId}'.sub('{' + 'userId' + '}', user_id.to_s)

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'UserResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user_by_id_0\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Get all user fields
    # Get all user fields within a project. <b>Rate limit</b>: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @return [GetUserFieldsResponse]
    def get_user_fields(opts = {})
      data, _status_code, _headers = get_user_fields_with_http_info(opts)
      data
    end

    # Get all user fields
    # Get all user fields within a project. &lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetUserFieldsResponse, Integer, Hash)>] GetUserFieldsResponse data, response status code and response headers
    def get_user_fields_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user_fields ...'
      end
      # resource path
      local_var_path = '/api/users/getFields'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      return_type = opts[:return_type] || 'GetUserFieldsResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:GET, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user_fields\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Invalidate all JWTs issued for a user
    # Invalidate all JWTs issued for a user before the current time or before the specified time.
    # @param body Invalid JWT request
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def invalidate_jwt(body, opts = {})
      invalidate_jwt_with_http_info(body, opts)
      nil
    end

    # Invalidate all JWTs issued for a user
    # Invalidate all JWTs issued for a user before the current time or before the specified time.
    # @param body Invalid JWT request
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def invalidate_jwt_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.invalidate_jwt ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.invalidate_jwt"
      end
      # resource path
      local_var_path = '/api/auth/jwts/invalidate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#invalidate_jwt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register a browser token for web push
    # There is a limit of 500 browser tokens per user profile. This API will return 400 error code if the user already has 500 tokens or more.
    # @param body Request to register browser
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def register_browser_token(body, opts = {})
      data, _status_code, _headers = register_browser_token_with_http_info(body, opts)
      data
    end

    # Register a browser token for web push
    # There is a limit of 500 browser tokens per user profile. This API will return 400 error code if the user already has 500 tokens or more.
    # @param body Request to register browser
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def register_browser_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.register_browser_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.register_browser_token"
      end
      # resource path
      local_var_path = '/api/users/registerBrowserToken'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#register_browser_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Register a device token for push
    # Register a device token for push. This will add the data if it doesn't exist yet. It will also update data fields on the device. Data will be merged; missing fields are not deleted. Also, note that there is a soft limit on the number of unique fields a user can have (default is 1,000). Types of data fields must match the types sent in previous requests, across all data fields in the project.<br><b>Limits</b>: There is a limit of 500 devices per user profile. This API will return 400 error code if the user already has 500 devices or more.<br><b>Rate limit</b>: 500 requests/second, per project.
    # @param body Request to register device
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def register_device_token(body, opts = {})
      data, _status_code, _headers = register_device_token_with_http_info(body, opts)
      data
    end

    # Register a device token for push
    # Register a device token for push. This will add the data if it doesn&#x27;t exist yet. It will also update data fields on the device. Data will be merged; missing fields are not deleted. Also, note that there is a soft limit on the number of unique fields a user can have (default is 1,000). Types of data fields must match the types sent in previous requests, across all data fields in the project.&lt;br&gt;&lt;b&gt;Limits&lt;/b&gt;: There is a limit of 500 devices per user profile. This API will return 400 error code if the user already has 500 devices or more.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 500 requests/second, per project.
    # @param body Request to register device
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def register_device_token_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.register_device_token ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.register_device_token"
      end
      # resource path
      local_var_path = '/api/users/registerDeviceToken'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#register_device_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Unforget a user in compliance with GDPR
    # Allow the Iterable project to resume collecting data about a previously forgotten user. Deleted data cannot be recovered.<br><b>Rate limit</b>: 3 requests/second, per project.
    # @param body user&#x27;s email to be removed from blacklist.
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def unforget(body, opts = {})
      data, _status_code, _headers = unforget_with_http_info(body, opts)
      data
    end

    # Unforget a user in compliance with GDPR
    # Allow the Iterable project to resume collecting data about a previously forgotten user. Deleted data cannot be recovered.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 3 requests/second, per project.
    # @param body user&#x27;s email to be removed from blacklist.
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def unforget_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.unforget ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.unforget"
      end
      # resource path
      local_var_path = '/api/users/unforget'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#unforget\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update user email
    # Change a user's email address. All profile data and events will be migrated to the new email address.
    # @param body Update a user&#x27;s email. All profile data and events will be migrated.
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def update_email(body, opts = {})
      data, _status_code, _headers = update_email_with_http_info(body, opts)
      data
    end

    # Update user email
    # Change a user&#x27;s email address. All profile data and events will be migrated to the new email address.
    # @param body Update a user&#x27;s email. All profile data and events will be migrated.
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def update_email_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.update_email ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.update_email"
      end
      # resource path
      local_var_path = '/api/users/updateEmail'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#update_email\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update user subscriptions
    # Update user subscriptions. <b>NOTE</b>: Overwrites existing data if the field is provided and not null.
    # @param body Subscriptions to update
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def update_subscriptions(body, opts = {})
      data, _status_code, _headers = update_subscriptions_with_http_info(body, opts)
      data
    end

    # Update user subscriptions
    # Update user subscriptions. &lt;b&gt;NOTE&lt;/b&gt;: Overwrites existing data if the field is provided and not null.
    # @param body Subscriptions to update
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def update_subscriptions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.update_subscriptions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.update_subscriptions"
      end
      # resource path
      local_var_path = '/api/users/updateSubscriptions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#update_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
    # Update user data
    # Update user data or adds a user if none exists. Data is merged - missing fields are not deleted. Please note there is a soft limit (default: 1,000) on the number of unique fields users can have. Types of data fields must match the types sent in previous requests, across all data fields in the project.<br><b>Rate limit</b>: 500 requests/second, per project.
    # @param body user object
    # @param [Hash] opts the optional parameters
    # @return [IterableApiResponse]
    def update_user(body, opts = {})
      data, _status_code, _headers = update_user_with_http_info(body, opts)
      data
    end

    # Update user data
    # Update user data or adds a user if none exists. Data is merged - missing fields are not deleted. Please note there is a soft limit (default: 1,000) on the number of unique fields users can have. Types of data fields must match the types sent in previous requests, across all data fields in the project.&lt;br&gt;&lt;b&gt;Rate limit&lt;/b&gt;: 500 requests/second, per project.
    # @param body user object
    # @param [Hash] opts the optional parameters
    # @return [Array<(IterableApiResponse, Integer, Hash)>] IterableApiResponse data, response status code and response headers
    def update_user_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.update_user ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling UsersApi.update_user"
      end
      # resource path
      local_var_path = '/api/users/update'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['*/*'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      return_type = opts[:return_type] || 'IterableApiResponse' 

      auth_names = opts[:auth_names] || ['api_key']
      data, status_code, headers = @api_client.call_api(:POST, local_var_path,
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type)

      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#update_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
